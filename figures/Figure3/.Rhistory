y.start=ys,
x.end=xe,
y.end=ye,
prop.drawn=pp,
displacement=0,
color=merge_arrow_color,
length=head.length,
angle=30,
width = arrow.width,
type=arrow.type.num)
}
}
}
}
}
for(g in 1:length(df[df$hosts==hosts[1],]$hosts)) { # loop through the number of genotypes (1 to 32)
for(h in hosts) { # loop through hosts (E.coli, Kleb, Se)
for(i in 1:length(df$hosts)) { # loop through rows (1 to 96)
if(df[i,1]==h & is.apart(df,N.loci,g,i,0)) { # if the row is for the particular host and matches the genotype 'g' then this is the focal genotype
focal.genotype <- i
break
}
}
# g: 1 through 32
# h: Ec, Kp, Se
# i: the line number for g in the data frame
neighbor.genotypes<-numeric(0)
for(i in 1:length(df$hosts)) { # loop through the rows
if(df[i,1]==h & is.apart(df,N.loci,focal.genotype,i,1)) { # if the host matches and the genotype differs by one mutation then store the row number for the neighbor genotype
neighbor.genotypes<-c(neighbor.genotypes,i)
}
}
merge.neighbor.genotypes <- vector(mode = "list", length = length(hosts))
names(merge.neighbor.genotypes) <- hosts
for(i in 1:length(df$hosts)) {
if(is.apart(df,N.loci,focal.genotype,i,1)) {
merge.neighbor.genotypes[[df[i,1]]] <- append(merge.neighbor.genotypes[[df[i,1]]], i)
}
}
merge.focal.genotypes <- vector(mode = "list", length = length(hosts))
names(merge.focal.genotypes) <- hosts
for(i in 1:length(df$hosts)) {
if(is.apart(df,N.loci,focal.genotype,i,0)) {
merge.focal.genotypes[[df[i,1]]] <- append(merge.focal.genotypes[[df[i,1]]], i)
}
}
for(n in neighbor.genotypes) { # loop through the neighbor genotypes
if (df$Num_of_mutations[focal.genotype] < df$Num_of_mutations[n]) {
arrow.type <- determine.direction.se(df,N.loci,N.fit.estimates,focal.genotype,n)
index = which(neighbor.genotypes == n)
merge.check <- vector()
for(s in hosts){
merge.check <- c(merge.check,determine.direction.se(df,N.loci,N.fit.estimates,merge.focal.genotypes[[s]],merge.neighbor.genotypes[[s]][index]))
}
if(arrow.type == "forward") {
xs <- df[focal.genotype,]$x
ys <- df[focal.genotype,]$y
xe <- df[n,]$x
ye <- df[n,]$y
head.length <- arrow.head
arrow.type.num <- 1
} else {
if(arrow.type == "backward") {
xe <- df[focal.genotype,]$x
ye <- df[focal.genotype,]$y
xs <- df[n,]$x
ys <- df[n,]$y
head.length <- arrow.head
arrow.type.num <- 5
} else {
xs <- df[focal.genotype,]$x
ys <- df[focal.genotype,]$y
xe <- df[n,]$x
ye <- df[n,]$y
head.length <- 0
arrow.type.num <- 3
}
}
p<-arrow.prop.drawn
delx <- (1-p)/2
lenx <- abs(xs-xe)
leny <- abs(ys-ye)
slope <- leny / lenx
len <- sqrt(1 + slope^2)
if(slope==0) {
pp<-p
} else {
pp <- 1 - (2*delx)/len
}
if(length(unique(merge.check)) != 1) {
draw.arrow(x.start=xs,
y.start=ys,
x.end=xe,
y.end=ye,
prop.drawn=pp,
displacement=arrow.host.displacements[which(hosts==h)],
color=arrow.host.colors[which(hosts==h)],
length=head.length,
angle=30,
width = arrow.width,
type=arrow.type.num)
}
}
}
}
}
new.df<-df[df$hosts==hosts[1],]
for(g in 1:length(new.df$hosts)) {
cols<-character(0)
t.cols<-character(0)
labs<-character(0)
for(p in 1:N.loci) {
if(new.df[g,1+p]==0) {
cols<-c(cols,starting.color)
t.cols<-c(t.cols,starting.text.color)
labs<-c(labs,starting.position.labels[p])
} else {
cols<-c(cols,ending.color)
t.cols<-c(t.cols,ending.text.color)
labs<-c(labs,ending.position.labels[p])
}
}
draw.pie(center.x = new.df[g,]$x,
center.y = new.df[g,]$y,
radius=node.radius,
edge.color=node.edge.color,
edge.width=node.edge.width,
start.angle=pi/2+pi/N.loci,
N.slices=N.loci,
label.size=node.label.size,
label.pos=label.pos,
colors=cols,
labels=labs,
text.colors=t.cols,
x.y.ratio=x.y.ratio)
}
## draw blowups
for(g in 1:length(new.df$hosts)) {
num_of_mutations = sum(new.df[g,2:(1+N.loci)])
if (num_of_mutations == 0 | num_of_mutations == N.loci){
if (num_of_mutations == 0){
xx <- c(new.df[g,]$x-node.radius, new.df[g,]$x+node.radius, new.df[g,]$x+blowup.node.radius, new.df[g,]$x-blowup.node.radius) #bottom left, bottom right, top right, top left
yy <- c(new.df[g,]$y, new.df[g,]$y, new.df[g,]$y+blowup.distance, new.df[g,]$y+blowup.distance)
y_store <- yy[3]
polygon(xx, yy, col=adjustcolor(pie_color,alpha.f = 0.25) , border=NA)
}
if (num_of_mutations == N.loci){
xx <- c(new.df[g,]$x-node.radius, new.df[g,]$x+node.radius, new.df[g,]$x+blowup.node.radius, new.df[g,]$x-blowup.node.radius)
yy <- c(new.df[g,]$y, new.df[g,]$y, new.df[g,]$y-blowup.distance, new.df[g,]$y-blowup.distance)
y_store <- yy[3]
polygon(xx, yy, col=adjustcolor(pie_color,alpha.f = 0.25), border=NA)
}
cols<-character(0)
t.cols<-character(0)
labs<-character(0)
blowuplabs<-character(0)
for(p in 1:N.loci) {
if(new.df[g,1+p]==0) {
cols<-c(cols,starting.color)
t.cols<-c(t.cols,starting.text.color)
labs<-c(labs,starting.position.labels[p])
blowuplabs<-c(blowuplabs,starting.blowup.labels[p])
} else {
cols<-c(cols,ending.color)
t.cols<-c(t.cols,ending.text.color)
labs<-c(labs,ending.position.labels[p])
blowuplabs<-c(blowuplabs,ending.blowup.labels[p])
}
}
draw.pie(center.x = new.df[g,]$x,
center.y = new.df[g,]$y,
radius=node.radius,
edge.color=node.edge.color,
edge.width=node.edge.width,
start.angle=pi/2+pi/N.loci,
N.slices=N.loci,
label.size=node.label.size,
label.pos=label.pos,
colors=cols,
labels=labs,
text.colors=t.cols,
x.y.ratio=x.y.ratio)
draw.pie(center.x = new.df[g,]$x,
center.y = y_store,
radius=blowup.node.radius,
edge.color=node.edge.color,
edge.width=node.edge.width,
start.angle=pi/2+pi/N.loci,
N.slices=N.loci,
label.size=node.label.size,
label.pos=label.pos,
colors=cols,
labels=blowuplabs,
text.colors=t.cols,
x.y.ratio=x.y.ratio)
}
}
}
draw.figure.TEM.network.blowups <-function(network.x.y.ratio,
buffer.x = 0.05,
buffer.y = c(0.2,0,0,0.2)){
df<-read.csv("inputs/resistance_levels.csv",header=TRUE)
plot.new()
draw.landscape.blowups(df,
N.loci=5,
starting.position.labels=c("","","","",""),
ending.position.labels=c("","","","",""),
starting.blowup.labels=c("g","A","E","M","G"),
ending.blowup.labels=c("a","G","K","T","S"),
N.fit.estimates=1,
buffer.x=buffer.x,
buffers.y=buffer.y,
node.radius=0.025,
blowup.node.radius=0.08,
blowup.distance=0.3,
node.edge.width=0.75,
node.label.size=1,
label.pos=.65,
node.edge.color='black',
starting.color="white",
ending.color=pie_color,
starting.text.color=pie_color,
ending.text.color="black",
merge_arrow_color=pie_arrow,
arrow.host.colors=c(red_Ec_color, blue_Kp_color, yellow_Se_color),
arrow.host.displacements=c(-0.012,0,0.012),
arrow.prop.drawn=0.6,
arrow.width=1.75,
arrow.head=.08,
gamma=1,
x.y.ratio=network.x.y.ratio)}
# Effect of mutations species correlations-----------
sp.slopes.df <- read.csv("inputs/mutational_step_slopes_only.csv")
sp.slopes <- sp.slopes.df %>%
select(-X)
Ec.main.label = expression('mutation effect in ' * phantom('Ec'))
Ec.sp.label = expression(phantom('mutation effect in ') * 'Ec')
Ec.label = c(Ec.main.label, Ec.sp.label)
Kp.main.label = expression('mutation effect in ' * phantom('Kp'))
Kp.sp.label = expression(phantom('mutation effect in ') * 'Kp')
Kp.label = c(Kp.main.label,Kp.sp.label)
Se.main.label = expression('mutation effect in ' * phantom('Se'))
Se.sp.label = expression(phantom('mutation effect in ') * 'Se')
Se.label = c(Se.main.label,Se.sp.label)
Ec.Kp.no.epistasis <- sp.slopes %>%
filter(Species %in% c('Ec','Kp')) %>%
pivot_wider(names_from = Species, values_from = c(step_slope,step_effect)) %>%
filter(step_effect_Ec == step_effect_Kp) %>%
rename(Ec = step_slope_Ec, Kp = step_slope_Kp)
Ec.Kp.yes.epistasis <- sp.slopes %>%
filter(Species %in% c('Ec','Kp')) %>%
pivot_wider(names_from = Species, values_from = c(step_slope,step_effect)) %>%
filter(step_effect_Ec != step_effect_Kp) %>%
rename(Ec = step_slope_Ec, Kp = step_slope_Kp)
Ec.Se.no.epistasis <- sp.slopes %>%
filter(Species %in% c('Ec','Se')) %>%
pivot_wider(names_from = Species, values_from = c(step_slope,step_effect)) %>%
filter(step_effect_Ec == step_effect_Se) %>%
rename(Ec = step_slope_Ec, Se = step_slope_Se)
Ec.Se.yes.epistasis <- sp.slopes %>%
filter(Species %in% c('Ec','Se')) %>%
pivot_wider(names_from = Species, values_from = c(step_slope,step_effect)) %>%
filter(step_effect_Ec != step_effect_Se) %>%
rename(Ec = step_slope_Ec, Se = step_slope_Se)
Kp.Se.no.epistasis <- sp.slopes %>%
filter(Species %in% c('Kp','Se')) %>%
pivot_wider(names_from = Species, values_from = c(step_slope,step_effect)) %>%
filter(step_effect_Kp == step_effect_Se) %>%
rename(Kp = step_slope_Kp, Se = step_slope_Se)
Kp.Se.yes.epistasis <- sp.slopes %>%
filter(Species %in% c('Kp','Se')) %>%
pivot_wider(names_from = Species, values_from = c(step_slope,step_effect)) %>%
filter(step_effect_Kp != step_effect_Se) %>%
rename(Kp = step_slope_Kp, Se = step_slope_Se)
correlation_plot <- function(df.no, df.yes, x.host, y.host, x.label, x.color, y.label, y.color, no.color, yes.color, global.cex, tick.cex = 1) {
plot((-2:22), (-2:22), type="n", xlab='', ylab='', frame.plot=F, axes = F)
mtext(side=1, line=0.6, text = c(x.label[1], x.label[2]), col=c("black", x.color), cex=global.cex)
mtext(side=2, line=0.6, text = c(y.label[1], y.label[2]), col=c("black", y.color), cex=global.cex)
points(as.list(df.no[x.host])[[1]], as.list(df.no[y.host])[[1]], pch=16, col=no.color, cex = 0.75, lwd=0.5)
points(as.list(df.yes[x.host])[[1]], as.list(df.yes[y.host])[[1]],pch=16, col=yes.color, cex = 0.75, lwd=0.5)
axis(side = 1, pos = 0, at = c(5,10,15,20), col.ticks = 'black', col = 'white', cex.axis=tick.cex, padj = -1.5, tck=-(0.05/b_square_in))
axis(side = 2, pos = 0, at = c(5,10,15,20), col.ticks = 'black', col = 'white', cex.axis=tick.cex, padj = 1.1, tck=-(0.05/b_square_in))
arrows(x0 = 0, y0 = -2, x1 = 0, y1 = 22, lwd = 1, length = 0.05)
arrows(x0 = -2, y0 = 0, x1 = 22, y1 = 0, lwd = 1, length = 0.05)
lines(-2:22, -2:22, lwd = 1, col = "black")
}
# Fitness landscapes ----------
fitness.landscape.graph <- function(host,
host.color,
xyratio,
axis.label = F,
radius.buffer,
node.radius,
global.cex) {
df<-read.csv("inputs/resistance_levels.csv",header=TRUE)
df.rel <- df %>%
group_by(hosts) %>%
mutate(MIC_WT = fit.1[Num_of_mutations == 0],
fit.1 = fit.1 - MIC_WT)
df.segments <- read.csv('inputs/mutational_step_slopes_rel.csv')
df.host <- df.rel %>% filter(hosts == host)
df.host.segments <- df.segments %>% filter(Species == host)
n_mut <- max(df.rel$Num_of_mutations)
plot(0:n_mut, seq((min(df.rel$fit.1)-0.5),(max(df.rel$fit.1)+0.5),length.out = 6), type="n", xaxt='n', xlab='', ylab='', axes=FALSE, frame.plot=TRUE)
axis(1, at = 0:n_mut, cex.axis=tick.cex, padj = -1.5, tck=-(0.05/c_square_w_in), lwd = 0, lwd.ticks = 1)
mtext(side=1, line=1.5, text = 'number of mutations', cex = global.cex)
if (axis.label == T) {
axis(2, at = seq(round(min(df.rel$fit.1)),round(max(df.rel$fit.1)),by = 5), cex = global.cex, cex.axis=tick.cex, padj = 1.1, tck=-(0.05/c_square_w_in), lwd = 0, lwd.ticks = 1)
mtext(side=2, line=1.5, text = 'relative resistance level', cex = global.cex)
} else {
axis(2, at = seq(round(min(df.rel$fit.1)),round(max(df.rel$fit.1)),by = 5), labels = FALSE, cex = global.cex, cex.axis=tick.cex, padj = 1.1, tck=-(0.05/c_square_w_in), lwd = 0, lwd.ticks = 1)
}
starting.color="white"
ending.color=pie_color
N.loci = 5
axis.multiplier = ((max(df.rel$fit.1)+0.5)-(min(df.rel$fit.1)-0.5))/N.loci
node.edge.color = 'black'
node.edge.width = 0.5
label.pos = 0.5
node.label.size = 0
x.y.ratio = xyratio
radius_filter = node.radius*radius.buffer*axis.multiplier*x.y.ratio
for (s in 1:length(df.host.segments$step)){
if (df.host.segments$step_effect[s] == 'neutral') {
arrows(x0 = df.host.segments$focal_num[s], y0 = df.host.segments$focal_MIC[s], x1 = df.host.segments$mutant_num[s], y1 = df.host.segments$mutant_MIC[s],
col = host.color, length=0, angle=30, code=1, lty = 3)
}
if (df.host.segments$step_effect[s] == 'deleterious') {
arrows(x0 = df.host.segments$focal_num[s], y0 = df.host.segments$focal_MIC[s], x1 = df.host.segments$mutant_num[s], y1 = df.host.segments$mutant_MIC[s],
col = host.color, length=0, angle=30, code=1, lty = 5)
}
if (df.host.segments$step_effect[s] == 'beneficial') {
arrows(x0 = df.host.segments$focal_num[s], y0 = df.host.segments$focal_MIC[s], x1 = df.host.segments$mutant_num[s], y1 = df.host.segments$mutant_MIC[s],
col = host.color, length=0, angle=30, code=1, lty = 1)
}
}
df.host <- df.host %>%
group_by(Num_of_mutations) %>%
arrange(fit.1)%>%
mutate(N = n(),
closest_below = fit.1 - lag(fit.1),
closest_above = lead(fit.1) - fit.1,
filter_below = ifelse(is.na(closest_below) | closest_below > radius_filter, T, F),
filter_above = ifelse(is.na(closest_above) | closest_above > radius_filter, T, F),
pie_filter = ifelse(filter_below == F | filter_above == F, F, T))
df.host.filter <- df.host %>%
filter(pie_filter == T)
offsets <- read.csv(file = "inputs/Offsets.csv")
offsets <- offsets %>%
select(hosts, g, A, E, M, G, xC, yC)
df.host$xC <- NULL
df.host$yC <- NULL
df.host <- left_join(df.host, offsets)
for(g in 1:length(df.host$hosts)) {
if (df.host[g,]$pie_filter == F) {
mA = (df.host[g,]$yC-df.host[g,]$fit.1)/(df.host[g,]$xC-df.host[g,]$Num_of_mutations)
mB = -1/mA
deltaX = node.radius*cos(atan(mB))
deltaY = node.radius*sin(atan(mB))*axis.multiplier*xyratio
x.values <- c(df.host[g,]$Num_of_mutations, df.host[g,]$xC+deltaX, df.host[g,]$xC-deltaX)
y.values <- c (y0 = df.host[g,]$fit.1, df.host[g,]$yC+deltaY, df.host[g,]$yC-deltaY)
polygon(x.values,y.values,border=NA,col=adjustcolor(pie_color,alpha.f = 0.45),lwd=0.1)
}
}
for(g in 1:length(df.host$hosts)) {
if (df.host[g,]$pie_filter == F) {
cols<-character(0)
for(p in 1:N.loci) {
if(df.host[g,1+p]==0) {
cols<-c(cols,starting.color)
} else {
cols<-c(cols,ending.color)
}
}
draw.pie.yaxis(center.x = df.host[g,]$xC,
center.y = df.host[g,]$yC,
radius=node.radius,
edge.color=node.edge.color,
edge.width=node.edge.width,
start.angle=pi/2+pi/N.loci,
N.slices=N.loci,
label.size=node.label.size,
label.pos=label.pos,
colors=cols,
labels='',
text.colors='black',
axis.multiplier=((max(df.rel$fit.1)+0.5)-(min(df.rel$fit.1)-0.5))/N.loci,
xy.ratio = xyratio)
}
}
points(df.host$Num_of_mutations, df.host$fit.1, pch = 21, col="black", bg=pie_color,cex = 0.5,lwd=0.4)
for(g in 1:length(df.host$hosts)) {
if (df.host[g,]$pie_filter == T) {
cols<-character(0)
for(p in 1:N.loci) {
if(df.host[g,1+p]==0) {
cols<-c(cols,starting.color)
} else {
cols<-c(cols,ending.color)
}
}
draw.pie.yaxis(center.x = df.host[g,]$Num_of_mutations,
center.y = df.host[g,]$fit.1,
radius=node.radius,
edge.color=node.edge.color,
edge.width=node.edge.width,
start.angle=pi/2+pi/N.loci,
N.slices=N.loci,
label.size=node.label.size,
label.pos=label.pos,
colors=cols,
labels='',
text.colors='black',
axis.multiplier=((max(df.rel$fit.1)+0.5)-(min(df.rel$fit.1)-0.5))/N.loci,
xy.ratio = xyratio)
}
}
}
# Arrange plot --------------
### Figure 3  --------------
matrix_layout <- as.matrix(read.csv('inputs/matrix.csv', header = F))
n.row = nrow(matrix_layout)
n.col = ncol(matrix_layout)
outer_margin = 0.01
tick_marks = 0.05
# columns
c1_left_margin = 0.45 + tick_marks
c1_right_margin = 0.25
c2_left_margin = 0 + tick_marks
c2_right_margin = 0.25
c3_left_margin = 0 + tick_marks
c3_right_margin = 0.13
# rows
r1_top_margin = 0
r1_bottom_margin = 0.35
r2_top_margin = 0
r2_bottom_margin = 0.35
r3_top_margin = 0
r3_bottom_margin = 0.35
r4_top_margin = 0
r4_bottom_margin = 0.4 + tick_marks
# b part dimensions
b_square_in = 1.25
b_left_margin = 0.6
b_right_margin = 1.93-0.6-1.25
# c part dimensions
c_square_h_in = 2
c_square_w_in = 1.75
# d part dimensions
d_square_h_in = 1.5
d_square_w_in = 1.75
c1 = c1_left_margin + c1_right_margin + c_square_w_in
c2 = c2_left_margin + c2_right_margin + c_square_w_in  # 2.05
c3 = c3_left_margin + c3_right_margin + c_square_w_in # 1.94
r1 = r1_bottom_margin + r1_top_margin + b_square_in  # 1.6
r2 = r2_bottom_margin + r2_top_margin + b_square_in  # 1.6
r3 = r3_bottom_margin + r3_top_margin + b_square_in # 1.6
r4 = r4_bottom_margin + r4_top_margin + c_square_h_in  # 2.45
pdf.width = c1 + c2 + c3 + (outer_margin*2) # 6.5 max
pdf.height = r1 + r2 + r3 + r4 + (outer_margin*2) # 9.25 max
### Initiate  --------
pointsize = 12
globalpointsize = 9
tickpointsize = 7
pdf(file = 'Fig3.pdf', width = pdf.width, height = pdf.height, pointsize = pointsize)
layout(matrix(matrix_layout, nrow = n.row, ncol = n.col),
widths = c(lcm(c1*2.54),lcm(c2*2.54),lcm(c3*2.54)),
heights = c(lcm(r1*2.54),lcm(r2*2.54),lcm(r3*2.54),lcm(r4*2.54)))
par(omi=c(outer_margin,outer_margin,outer_margin,outer_margin)) # outer margins (b, l, t, r)
global.cex = globalpointsize / pointsize
tick.cex = tickpointsize / globalpointsize
### Panel A----------
par(mai=c(0,0,0,0), cex = global.cex) # margins
panel.A.x.y.ratio = (c1 + c2) / (r1 + r2 + r3)
draw.figure.TEM.network.blowups(panel.A.x.y.ratio, buffer.y = c(0.21,0.01,0.01,0.21))
mtext("a", line = -1.1, side=3, at = -0.02)
### Panel B---------
par(mai=c(r1_bottom_margin,b_left_margin,r1_top_margin,b_right_margin), cex = global.cex) # margins
correlation_plot(df.no = Ec.Kp.no.epistasis, df.yes = Ec.Kp.yes.epistasis, x.host = 'Ec', y.host = 'Kp', x.label = Ec.label, y.label = Kp.label, x.color = red_Ec_color, y.color = blue_Kp_color, no.color = pie_arrow, yes.color = purple_Ec.Kp_color, global.cex = global.cex, tick.cex = tick.cex)
mtext("b", line = -1.1, side=3, at = -13)
correlation_plot(df.no = Kp.Se.no.epistasis, df.yes = Kp.Se.yes.epistasis, x.host = 'Kp', y.host = 'Se', x.label = Kp.label, y.label = Se.label, x.color = blue_Kp_color, y.color = yellow_Se_color, no.color = pie_arrow, yes.color = green_Se.Kp_color, global.cex = global.cex, tick.cex = tick.cex)
correlation_plot(df.no = Ec.Se.no.epistasis, df.yes = Ec.Se.yes.epistasis, x.host = 'Se', y.host = 'Ec', x.label =  Se.label, y.label = Ec.label, x.color = yellow_Se_color, y.color = red_Ec_color, no.color = pie_arrow, yes.color = orange_Ec.Se_color, global.cex = global.cex, tick.cex = tick.cex)
### Panel C------------
par(mai=c(r4_bottom_margin,c1_left_margin,r4_top_margin,c1_right_margin), cex = global.cex)
xyratio.pdf <- c_square_w_in/c_square_h_in
radiusbuffer = 1.2
noderadius = 0.125 #0.125
fitness.landscape.graph(host = 'Ec',
host.color = red_Ec_color,
xyratio = xyratio.pdf,
axis.label = T,
radius.buffer = radiusbuffer,
node.radius = noderadius,
global.cex = global.cex)
mtext("c", line = -0.5, side=3, at = -1.5, cex = 1)
par(mai=c(r4_bottom_margin,c2_left_margin,r4_top_margin,c2_right_margin), cex = global.cex)
fitness.landscape.graph(host = 'Kp',
host.color = blue_Kp_color,
xyratio = xyratio.pdf,
axis.label = F,
radius.buffer = radiusbuffer,
node.radius = noderadius,
global.cex = global.cex)
par(mai=c(r4_bottom_margin,c3_left_margin,r4_top_margin,c3_right_margin), cex = global.cex)
fitness.landscape.graph(host = 'Se',
host.color = yellow_Se_color,
xyratio = xyratio.pdf,
axis.label = F,
radius.buffer = radiusbuffer,
node.radius = noderadius,
global.cex = global.cex)
dev.off()

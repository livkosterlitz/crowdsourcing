mutant <- left_join(master.landscape.df, mutant_step, multiple = "all")
mutant$identity <- 'mutant'
full_data <- full_join(focal, mutant)
full <- full_data %>%
separate(col = step, sep = '->', into = c('focal', 'mutant'), remove = F) %>%
filter(!(is.na(focal))) %>%
group_by(Species, step) %>%
mutate(focal_MIC = mic[Genotype == focal],
mutant_MIC = mic[Genotype == mutant],
step_slope = (mutant_MIC) - (focal_MIC),
step_effect = case_when((mutant_MIC) > (focal_MIC) ~ 'beneficial',
(mutant_MIC) < (focal_MIC) ~ 'deleterious',
TRUE ~ 'neutral')) %>%
group_by(step) %>%
mutate(host_epistasis = ifelse(length(unique(step_effect)) == 1, 'noGxH', 'GxH')) %>%
group_by(Genotype, Species) %>%
mutate(peak = all((identity == 'focal' & step_effect == 'deleterious')|
(identity == 'mutant' & step_effect == 'beneficial')),
peak_color = ifelse(peak == T, id, 33)) %>%
ungroup() %>%
group_by(Genotype) %>%
mutate(not_shared_peak = any(peak == T) & any(peak == F),
peak_color = ifelse(any(peak == T), id, 33))
color_mapping <- setNames(c('black','white', 'grey','black'), c(T, F, 'noGxH', 'GxH'))
perturbed_landscape_plot <- ggplot(data = full %>% filter(Species == focal_host), aes(x = num_of_mutations, y = mic, group = step)) +
geom_line(data = full %>% filter(Species == focal_host & host_epistasis == 'noGxH'), aes(linetype = step_effect), color = 'grey', size = 0.3)+
geom_line(data = full %>% filter(Species == focal_host & host_epistasis == 'GxH'), aes(linetype = step_effect), color = 'black', size = 0.3)+
geom_point(shape = 21, size = 1.5, stroke = 0.5, fill = 'grey', color = 'white') +
geom_point(data = full %>% filter(Species == focal_host & peak_color != 33), aes(fill = as.factor(peak_color), color = peak), shape = 21, size = 1.5, stroke = 0.5) +
scale_fill_manual(values = fill_mapping)+
scale_color_manual(values = color_mapping)+
scale_linetype_manual(values = c('solid','longdash','dotted')) +
theme(legend.position = "none")+
ylab('fitness')+
xlab('number of mutations')
if (focal_host == 'Kp') {
perturbed_landscape_plot <- perturbed_landscape_plot +
theme(
axis.text.y = element_blank(),
axis.title.y = element_blank())
}
return(perturbed_landscape_plot)
}
mutation_effects_plot <- function(Pid) {
sd_value = 0.125
landscapes <- random_landscape(seed = Pid, sd_value = sd_value)
mutant_steps <- step_effects(landscapes)
perturbed_step_effects <- mutant_steps %>%
select(Species, step, step_slope) %>%
pivot_wider(names_from = Species, values_from = step_slope) %>%
mutate(GxH = (Ec > 0 & Kp < 0) | (Ec < 0 & Kp > 0))
mutant_effects <- ggplot(perturbed_step_effects, aes(x = Ec, y = Kp)) +
geom_point(aes(color = GxH), size = 0.75)+
geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey") +
geom_abline(intercept = 0, slope = 1, color = "black")+
theme(legend.position = "none")+
scale_color_manual(values = c('grey', 'black'))+
scale_y_continuous(limits = c(-0.5, 0.65),
breaks = c(-0.5, -0.25, 0, 0.25, 0.5),
labels = c("-0.5", "", "0", "", "0.5"))+
scale_x_continuous(limits = c(-0.5, 0.65),
breaks = c(-0.5, -0.25, 0, 0.25, 0.5),
labels = c("-0.5", "", "0", "", "0.5"))+
ylab("mutation effect in T")+
xlab("mutation effect in F")
return(mutant_effects)
}
evo_outcome_plot <- function(Pid) {
df <- read.csv("inputs/plot_combined_data.csv")
mapping <- c('Ec_N' = 'Focal only', 'Ec_HGT' = 'Focal with HGT to transient')
df <- df  %>%
filter(Partition_ID == Pid) %>%
mutate(Treatment_ID = recode(Treatment_ID, !!!mapping)) %>%
mutate(Treatment_ID = factor(Treatment_ID, levels = c('Focal only', 'Focal with HGT to transient')))%>%
group_by(Partition_ID, bin) %>%
nest() %>%
mutate(p_value = map_dbl(data, ~ perform_wilcoxon(.x$Resistance[.x$Treatment_ID == 'Focal only'],
.x$Resistance[.x$Treatment_ID == 'Focal with HGT to transient'])),
Ec_N_mean = map_dbl(data, ~ calculate_mean_resistance(.x$Resistance[.x$Treatment_ID == 'Focal only'])),
Ec_HGT_mean = map_dbl(data, ~ calculate_mean_resistance(.x$Resistance[.x$Treatment_ID == 'Focal with HGT to transient']))) %>%
ungroup() %>%
group_by(bin) %>%
mutate(num_bin_comparisons = n()) %>%
ungroup() %>%
mutate(corrected_alpha = 0.05 / num_bin_comparisons) %>% #Bonferonni correction based on the number of comparisons within a bin
mutate(significant = p_value < corrected_alpha) %>%
mutate(difference = Ec_N_mean - Ec_HGT_mean) %>%
mutate(outcome = case_when(significant & difference < 0 ~ "outsourcing",
significant & difference > 0 ~ "insourcing",
TRUE ~ "crowdsourcing")) %>%
select(-corrected_alpha)
y_axis_label = expression(paste("fitness"))
margins <- c(0.1,0.1,0.1,0.1)
landscapes <- random_landscape(seed = df$Partition_ID, sd_value = 0.125)
master.landscape.df <- landscapes %>%
mutate(num_of_mutations = g + A + E + G + M)
steps_file <- read.csv('inputs/mutational_steps.csv', header = T)
steps <- steps_file %>%
mutate(step = paste(focal, mutant, sep = "->"))
focal_node <- steps %>%
select(-mutant) %>%
rename(Genotype = focal)
mutant_step <- steps  %>%
select(-focal) %>%
rename(Genotype = mutant)
focal <- left_join(master.landscape.df, focal_node, multiple = "all")
focal$identity <- 'focal'
mutant <- left_join(master.landscape.df, mutant_step, multiple = "all")
mutant$identity <- 'mutant'
full_data <- full_join(focal, mutant)
full <- full_data %>%
separate(col = step, sep = '->', into = c('focal', 'mutant'), remove = F) %>%
filter(!(is.na(focal))) %>%
group_by(Species, step) %>%
mutate(focal_MIC = mic[Genotype == focal],
mutant_MIC = mic[Genotype == mutant],
step_slope = (mutant_MIC) - (focal_MIC),
step_effect = case_when((mutant_MIC) > (focal_MIC) ~ 'beneficial',
(mutant_MIC) < (focal_MIC) ~ 'deleterious',
TRUE ~ 'neutral')) %>%
group_by(step) %>%
mutate(host_epistasis = ifelse(length(unique(step_effect)) == 1, 'noGxH', 'GxH')) %>%
group_by(Genotype, Species) %>%
mutate(peak = all((identity == 'focal' & step_effect == 'deleterious')|
(identity == 'mutant' & step_effect == 'beneficial')),
peak_color = ifelse(peak == T, id, 33)) %>%
ungroup() %>%
group_by(Genotype) %>%
mutate(not_shared_peak = any(peak == T) & any(peak == F),
peak_color = ifelse(any(peak == T), id, 33))
my_comparisons <- list(c('Focal only', 'Focal with HGT to transient'))
peak_info <- full %>%
ungroup() %>%
select(id, peak_color) %>%
rename(Genotype = id) %>%
distinct()
df$data[[1]] <- left_join(df$data[[1]], peak_info)
# wrapped_label <- str_wrap(my_comparisons[[1]][2], width = 15)  # Adjust the width as needed
plot <- ggplot(data = df$data[[1]], aes(x = Treatment_ID, y = Resistance)) +
geom_violin(width = 1)+
geom_jitter(aes(color = as.factor(peak_color)), width = 0.15, size = 1, alpha = 0.075)+
stat_summary(fun = "mean", geom = "point", color = "black", size = 2)+
#stat_summary(aes(color = Treatment_ID), fun.data=MinMeanSEMMax, geom="boxplot", size = box_line_size, color = 'dark grey', width = 0.15)+
geom_hline(yintercept = df$Ec_N_mean, linetype = 'dashed', color = 'black')+
#geom_bracket(xmin = 'Focal only', xmax = 'Focal with HGT to transient', y = max(df$data[[1]]$Resistance, na.rm = T) * 1.1, label = df$outcome[1])+
theme(legend.position = "none") +
ylab(y_axis_label)+
xlab(" ")+
scale_color_manual(values = fill_mapping)+
#scale_y_continuous(limits = c(0, 1.1), breaks = seq(0, 1, by = 0.25))+
scale_x_discrete(breaks = c('Focal only', 'Focal with HGT to transient'), labels = c('F', 'F-T'))+
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
return(plot)
}
# landscape parts ####
# low misalignment
pA <- landscape_plot(1077, 'Ec')
pB <- landscape_plot(1077, 'Kp')
pC <- evo_outcome_plot(1077)
pG <- mutation_effects_plot(1077)
# high misalignment
pD <- landscape_plot(5770, 'Ec')
pE <- landscape_plot(5770, 'Kp')
pF <- evo_outcome_plot(5770)
pI <- mutation_effects_plot(5770)
# misalignment versues outcome frequency #####
bin_verse_outcome <- read.csv(file = "inputs/misalignment_versus_outcome_frequency.csv")
crowdsourcing_color <- '#D53E4F' #rgb(255, 128, 128, maxColorValue = 255)
insourcing_color <- '#BF812D' #rgb(180, 130, 180, maxColorValue = 255)
outsourcing_color <- '#FB9A99' #rgb(255, 200, 140, maxColorValue = 255)
# Get the palette colors
pH <- ggplot(data = bin_verse_outcome, aes(x = bin, y = freq_outcome, color = outcome)) +
geom_smooth(method = "lm", se = FALSE, formula = y ~ x)+
geom_point(data = bin_verse_outcome %>% filter(outcome == 'crowdsourcing'), shape = 23, size = 1, fill = crowdsourcing_color)+
geom_point(data = bin_verse_outcome %>% filter(outcome == 'outsourcing'), shape = 24, size = 1, fill = outsourcing_color)+
#geom_point(data = bin_verse_outcome %>% filter(outcome == 'outsourcing'), shape = 8, size = 0.5, color = 'black')+
geom_point(data = bin_verse_outcome %>% filter(outcome == 'insourcing'), shape = 25, size = 1, fill = insourcing_color)+
#geom_point(data = bin_verse_outcome %>% filter(outcome == 'insourcing'), shape = 8, size = 0.5, color = 'black')+
#stat_cor(method = "pearson", label.x = 8) +
scale_y_continuous(limits = c(0, 1),
breaks = c(0, .25, 0.5, 0.75, 1.0),
labels = c("0.0", "", "0.5", "", "1.0"))+
scale_x_continuous(limits = c(0, 12.5),
breaks = c(0, 2, 4, 6, 8, 10, 12),
labels = c("0", "", "4", "", "8", "", "12"))+
ylab('outcome frequency') +
xlab('misalignment score')+
scale_color_manual(values = c("crowdsourcing" = crowdsourcing_color,
"outsourcing" = outsourcing_color,
"insourcing" = insourcing_color))+
theme(legend.position = "none")
# assembly ####
pA_width = 1.5
pC_width = 1.5
pA_height = 1.5
pG_width = 1.5
pG_height = 1.5
pH_width = 2
gA <- set_panel_size(pA, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gB <- set_panel_size(pB, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gC <- set_panel_size(pC, width  = unit(pC_width, "in"), height = unit(pA_height, "in"))
gABC_rel_widths <- c(2.0654/6.5, 1.7421/6.5, 1.7421/6.5, 0.95/6.5)
gABC <- plot_grid(gA,gB,gC,NULL, nrow = 1, rel_widths = gABC_rel_widths)
gD <- set_panel_size(pD, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gE <- set_panel_size(pE, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gF <- set_panel_size(pF, width  = unit(pC_width, "in"), height = unit(pA_height, "in"))
gDEF_rel_widths <- c(0.95/6.5, 2.0654/6.5, 1.7421/6.5, 1.7421/6.5)
gDEF <- plot_grid(NULL,gD,gE,gF, nrow = 1, rel_widths = gDEF_rel_widths)
gG <- set_panel_size(pG, width  = unit(pG_width, "in"), height = unit(pG_height, "in"))
gH <- set_panel_size(pH, width  = unit(pH_width, "in"), height = unit(pA_height, "in"))
gI <- set_panel_size(pI, width  = unit(pG_width, "in"), height = unit(pG_height, "in"))
gGHI <- plot_grid(gG,gH,gI, nrow = 1, rel_widths = c(0.31, (1-(0.31*2)), 0.31))
Figure5 <- plot_grid(gABC, gDEF, gGHI, nrow = 3)
save_plot("Figure5_parts.pdf", plot = Figure5, base_width = 6.5, base_height = 6.5)
# packages #####
library(tidyverse)
library(ggpubr)
library(cowplot)
library(egg)
library(RColorBrewer)
source("src/Random_Landscape_Functions.R")
theme_set(theme_cowplot() +
theme(
text = element_text(size = 9),
axis.title = element_text(size = 9),
axis.text = element_text(size = 7),
legend.title = element_text(size = 9),
legend.text = element_text(size = 9),
plot.title = element_text(size = 9),
plot.subtitle = element_text(size = 9),
plot.caption = element_text(size = 9),
strip.text = element_text(size = 9)
)
)
# colors #####
n <- 32  # Number of colors you want to generate
default_scale <- scale_colour_hue()
palette_fun <- default_scale$palette
colors <- palette_fun(n)
fill_palette <- c("#C0C0C0",
"#C0C0C0",
"#9F8CFF", #peak 1 mutation
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#7CAE00", #peak 3 mutations
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#00C0B3", #peak 2 mutations
"#9DA700", #peak 3 mutations
"#C0C0C0",
"#C0C0C0",
"#66B200", #peak 3 mutations
"#C0C0C0",
"#C0C0C0",
"#00BD5D", #peak 3 mutations
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#C0C0C0",
"#22A3FF", #global peak
"#C0C0C0")
fill_mapping <- setNames(fill_palette, 1:33)
# for editing colors https://scales.r-lib.org/reference/hue_pal.html
# landscape_plot(5770, 'Ec')
# evo_outcome_plot(5770)
brewer.pal(9, "GnBu")
palette_fun <- default_scale$palette
colors <- palette_fun(n)
# plot functions ####
landscape_plot <- function(Pid, focal_host) {
landscapes <- random_landscape(seed = Pid, sd_value = 0.125)
master.landscape.df <- landscapes %>%
mutate(num_of_mutations = g + A + E + G + M)
steps_file <- read.csv('inputs/mutational_steps.csv', header = T)
steps <- steps_file %>%
mutate(step = paste(focal, mutant, sep = "->"))
focal_node <- steps %>%
select(-mutant) %>%
rename(Genotype = focal)
mutant_step <- steps  %>%
select(-focal) %>%
rename(Genotype = mutant)
focal <- left_join(master.landscape.df, focal_node, multiple = "all")
focal$identity <- 'focal'
mutant <- left_join(master.landscape.df, mutant_step, multiple = "all")
mutant$identity <- 'mutant'
full_data <- full_join(focal, mutant)
full <- full_data %>%
separate(col = step, sep = '->', into = c('focal', 'mutant'), remove = F) %>%
filter(!(is.na(focal))) %>%
group_by(Species, step) %>%
mutate(focal_MIC = mic[Genotype == focal],
mutant_MIC = mic[Genotype == mutant],
step_slope = (mutant_MIC) - (focal_MIC),
step_effect = case_when((mutant_MIC) > (focal_MIC) ~ 'beneficial',
(mutant_MIC) < (focal_MIC) ~ 'deleterious',
TRUE ~ 'neutral')) %>%
group_by(step) %>%
mutate(host_epistasis = ifelse(length(unique(step_effect)) == 1, 'noGxH', 'GxH')) %>%
group_by(Genotype, Species) %>%
mutate(peak = all((identity == 'focal' & step_effect == 'deleterious')|
(identity == 'mutant' & step_effect == 'beneficial')),
peak_color = ifelse(peak == T, id, 33)) %>%
ungroup() %>%
group_by(Genotype) %>%
mutate(not_shared_peak = any(peak == T) & any(peak == F),
peak_color = ifelse(any(peak == T), id, 33))
color_mapping <- setNames(c('black','white', 'grey','black'), c(T, F, 'noGxH', 'GxH'))
perturbed_landscape_plot <- ggplot(data = full %>% filter(Species == focal_host), aes(x = num_of_mutations, y = mic, group = step)) +
geom_line(data = full %>% filter(Species == focal_host & host_epistasis == 'noGxH'), aes(linetype = step_effect), color = 'grey', size = 0.3)+
geom_line(data = full %>% filter(Species == focal_host & host_epistasis == 'GxH'), aes(linetype = step_effect), color = 'black', size = 0.3)+
geom_point(shape = 21, size = 1.5, stroke = 0.5, fill = 'grey', color = 'white') +
geom_point(data = full %>% filter(Species == focal_host & peak_color != 33), aes(fill = as.factor(peak_color), color = peak), shape = 21, size = 1.5, stroke = 0.5) +
scale_fill_manual(values = fill_mapping)+
scale_color_manual(values = color_mapping)+
scale_linetype_manual(values = c('solid','longdash','dotted')) +
theme(legend.position = "none")+
ylab('fitness')+
xlab('number of mutations')
if (focal_host == 'Kp') {
perturbed_landscape_plot <- perturbed_landscape_plot +
theme(
axis.text.y = element_blank(),
axis.title.y = element_blank())
}
return(perturbed_landscape_plot)
}
mutation_effects_plot <- function(Pid) {
sd_value = 0.125
landscapes <- random_landscape(seed = Pid, sd_value = sd_value)
mutant_steps <- step_effects(landscapes)
perturbed_step_effects <- mutant_steps %>%
select(Species, step, step_slope) %>%
pivot_wider(names_from = Species, values_from = step_slope) %>%
mutate(GxH = (Ec > 0 & Kp < 0) | (Ec < 0 & Kp > 0))
mutant_effects <- ggplot(perturbed_step_effects, aes(x = Ec, y = Kp)) +
geom_point(aes(color = GxH), size = 0.75)+
geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey") +
geom_abline(intercept = 0, slope = 1, color = "black")+
theme(legend.position = "none")+
scale_color_manual(values = c('grey', 'black'))+
scale_y_continuous(limits = c(-0.5, 0.65),
breaks = c(-0.5, -0.25, 0, 0.25, 0.5),
labels = c("-0.5", "", "0", "", "0.5"))+
scale_x_continuous(limits = c(-0.5, 0.65),
breaks = c(-0.5, -0.25, 0, 0.25, 0.5),
labels = c("-0.5", "", "0", "", "0.5"))+
ylab("mutation effect in T")+
xlab("mutation effect in F")
return(mutant_effects)
}
evo_outcome_plot <- function(Pid) {
df <- read.csv("inputs/plot_combined_data.csv")
mapping <- c('Ec_N' = 'Focal only', 'Ec_HGT' = 'Focal with HGT to transient')
df <- df  %>%
filter(Partition_ID == Pid) %>%
mutate(Treatment_ID = recode(Treatment_ID, !!!mapping)) %>%
mutate(Treatment_ID = factor(Treatment_ID, levels = c('Focal only', 'Focal with HGT to transient')))%>%
group_by(Partition_ID, bin) %>%
nest() %>%
mutate(p_value = map_dbl(data, ~ perform_wilcoxon(.x$Resistance[.x$Treatment_ID == 'Focal only'],
.x$Resistance[.x$Treatment_ID == 'Focal with HGT to transient'])),
Ec_N_mean = map_dbl(data, ~ calculate_mean_resistance(.x$Resistance[.x$Treatment_ID == 'Focal only'])),
Ec_HGT_mean = map_dbl(data, ~ calculate_mean_resistance(.x$Resistance[.x$Treatment_ID == 'Focal with HGT to transient']))) %>%
ungroup() %>%
group_by(bin) %>%
mutate(num_bin_comparisons = n()) %>%
ungroup() %>%
mutate(corrected_alpha = 0.05 / num_bin_comparisons) %>% #Bonferonni correction based on the number of comparisons within a bin
mutate(significant = p_value < corrected_alpha) %>%
mutate(difference = Ec_N_mean - Ec_HGT_mean) %>%
mutate(outcome = case_when(significant & difference < 0 ~ "outsourcing",
significant & difference > 0 ~ "insourcing",
TRUE ~ "crowdsourcing")) %>%
select(-corrected_alpha)
y_axis_label = expression(paste("fitness"))
margins <- c(0.1,0.1,0.1,0.1)
landscapes <- random_landscape(seed = df$Partition_ID, sd_value = 0.125)
master.landscape.df <- landscapes %>%
mutate(num_of_mutations = g + A + E + G + M)
steps_file <- read.csv('inputs/mutational_steps.csv', header = T)
steps <- steps_file %>%
mutate(step = paste(focal, mutant, sep = "->"))
focal_node <- steps %>%
select(-mutant) %>%
rename(Genotype = focal)
mutant_step <- steps  %>%
select(-focal) %>%
rename(Genotype = mutant)
focal <- left_join(master.landscape.df, focal_node, multiple = "all")
focal$identity <- 'focal'
mutant <- left_join(master.landscape.df, mutant_step, multiple = "all")
mutant$identity <- 'mutant'
full_data <- full_join(focal, mutant)
full <- full_data %>%
separate(col = step, sep = '->', into = c('focal', 'mutant'), remove = F) %>%
filter(!(is.na(focal))) %>%
group_by(Species, step) %>%
mutate(focal_MIC = mic[Genotype == focal],
mutant_MIC = mic[Genotype == mutant],
step_slope = (mutant_MIC) - (focal_MIC),
step_effect = case_when((mutant_MIC) > (focal_MIC) ~ 'beneficial',
(mutant_MIC) < (focal_MIC) ~ 'deleterious',
TRUE ~ 'neutral')) %>%
group_by(step) %>%
mutate(host_epistasis = ifelse(length(unique(step_effect)) == 1, 'noGxH', 'GxH')) %>%
group_by(Genotype, Species) %>%
mutate(peak = all((identity == 'focal' & step_effect == 'deleterious')|
(identity == 'mutant' & step_effect == 'beneficial')),
peak_color = ifelse(peak == T, id, 33)) %>%
ungroup() %>%
group_by(Genotype) %>%
mutate(not_shared_peak = any(peak == T) & any(peak == F),
peak_color = ifelse(any(peak == T), id, 33))
my_comparisons <- list(c('Focal only', 'Focal with HGT to transient'))
peak_info <- full %>%
ungroup() %>%
select(id, peak_color) %>%
rename(Genotype = id) %>%
distinct()
df$data[[1]] <- left_join(df$data[[1]], peak_info)
# wrapped_label <- str_wrap(my_comparisons[[1]][2], width = 15)  # Adjust the width as needed
plot <- ggplot(data = df$data[[1]], aes(x = Treatment_ID, y = Resistance)) +
geom_violin(width = 1)+
geom_jitter(aes(color = as.factor(peak_color)), width = 0.15, size = 1, alpha = 0.075)+
stat_summary(fun = "mean", geom = "point", color = "black", size = 2)+
#stat_summary(aes(color = Treatment_ID), fun.data=MinMeanSEMMax, geom="boxplot", size = box_line_size, color = 'dark grey', width = 0.15)+
geom_hline(yintercept = df$Ec_N_mean, linetype = 'dashed', color = 'black')+
#geom_bracket(xmin = 'Focal only', xmax = 'Focal with HGT to transient', y = max(df$data[[1]]$Resistance, na.rm = T) * 1.1, label = df$outcome[1])+
theme(legend.position = "none") +
ylab(y_axis_label)+
xlab(" ")+
scale_color_manual(values = fill_mapping)+
#scale_y_continuous(limits = c(0, 1.1), breaks = seq(0, 1, by = 0.25))+
scale_x_discrete(breaks = c('Focal only', 'Focal with HGT to transient'), labels = c('F', 'F-T'))+
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
return(plot)
}
# landscape parts ####
# low misalignment
pA <- landscape_plot(1077, 'Ec')
pB <- landscape_plot(1077, 'Kp')
pC <- evo_outcome_plot(1077)
pG <- mutation_effects_plot(1077)
# high misalignment
pD <- landscape_plot(5770, 'Ec')
pE <- landscape_plot(5770, 'Kp')
pF <- evo_outcome_plot(5770)
pI <- mutation_effects_plot(5770)
# misalignment versues outcome frequency #####
bin_verse_outcome <- read.csv(file = "inputs/misalignment_versus_outcome_frequency.csv")
crowdsourcing_color <- '#D53E4F' #rgb(255, 128, 128, maxColorValue = 255)
insourcing_color <- '#FB9A99' #rgb(180, 130, 180, maxColorValue = 255)
outsourcing_color <- '#BF812D' #rgb(255, 200, 140, maxColorValue = 255)
pH <- ggplot(data = bin_verse_outcome, aes(x = bin, y = freq_outcome, color = outcome)) +
geom_smooth(method = "lm", se = FALSE, formula = y ~ x)+
geom_point(data = bin_verse_outcome %>% filter(outcome == 'crowdsourcing'), shape = 23, size = 1, fill = crowdsourcing_color)+
geom_point(data = bin_verse_outcome %>% filter(outcome == 'outsourcing'), shape = 24, size = 1, fill = outsourcing_color)+
#geom_point(data = bin_verse_outcome %>% filter(outcome == 'outsourcing'), shape = 8, size = 0.5, color = 'black')+
geom_point(data = bin_verse_outcome %>% filter(outcome == 'insourcing'), shape = 25, size = 1, fill = insourcing_color)+
#geom_point(data = bin_verse_outcome %>% filter(outcome == 'insourcing'), shape = 8, size = 0.5, color = 'black')+
#stat_cor(method = "pearson", label.x = 8) +
scale_y_continuous(limits = c(0, 1),
breaks = c(0, .25, 0.5, 0.75, 1.0),
labels = c("0.0", "", "0.5", "", "1.0"))+
scale_x_continuous(limits = c(0, 12.5),
breaks = c(0, 2, 4, 6, 8, 10, 12),
labels = c("0", "", "4", "", "8", "", "12"))+
ylab('outcome frequency') +
xlab('misalignment score')+
scale_color_manual(values = c("crowdsourcing" = crowdsourcing_color,
"outsourcing" = outsourcing_color,
"insourcing" = insourcing_color))+
theme(legend.position = "none")
# assembly ####
pA_width = 1.5
pC_width = 1.5
pA_height = 1.5
pG_width = 1.5
pG_height = 1.5
pH_width = 2
gA <- set_panel_size(pA, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gB <- set_panel_size(pB, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gC <- set_panel_size(pC, width  = unit(pC_width, "in"), height = unit(pA_height, "in"))
gABC_rel_widths <- c(2.0654/6.5, 1.7421/6.5, 1.7421/6.5, 0.95/6.5)
gABC <- plot_grid(gA,gB,gC,NULL, nrow = 1, rel_widths = gABC_rel_widths)
gD <- set_panel_size(pD, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gE <- set_panel_size(pE, width  = unit(pA_width, "in"), height = unit(pA_height, "in"))
gF <- set_panel_size(pF, width  = unit(pC_width, "in"), height = unit(pA_height, "in"))
gDEF_rel_widths <- c(0.95/6.5, 2.0654/6.5, 1.7421/6.5, 1.7421/6.5)
gDEF <- plot_grid(NULL,gD,gE,gF, nrow = 1, rel_widths = gDEF_rel_widths)
gG <- set_panel_size(pG, width  = unit(pG_width, "in"), height = unit(pG_height, "in"))
gH <- set_panel_size(pH, width  = unit(pH_width, "in"), height = unit(pA_height, "in"))
gI <- set_panel_size(pI, width  = unit(pG_width, "in"), height = unit(pG_height, "in"))
gGHI <- plot_grid(gG,gH,gI, nrow = 1, rel_widths = c(0.31, (1-(0.31*2)), 0.31))
Figure5 <- plot_grid(gABC, gDEF, gGHI, nrow = 3)
save_plot("Figure5_parts.pdf", plot = Figure5, base_width = 6.5, base_height = 6.5)
